#include <eflags.h>

/*
 the EFLAGS register is the status register in the x86

 Notes:
    the IF (interrupt enable flag) does not affect the handling of NMI or
    software interrupts generated by the INT instruction
 */
typedef struct {
    unsigned int    CF      :   1;  //   0      carry flag
    unsigned int            :   1;  //   1      reserved
    unsigned int    PF      :   1;  //   2      parity flag
    unsigned int            :   1;  //   3      reserved
    unsigned int    AF      :   1;  //   4      adjust flag
    unsigned int            :   1;  //   5      reserved
    unsigned int    ZF      :   1;  //   6      zero flag
    unsigned int    SF      :   1;  //   7      sign flag
    unsigned int    TF      :   1;  //   8      trap flag
    unsigned int    IF      :   1;  //   9      interrupt enable flag
    unsigned int    DF      :   1;  //  10      direction flag
    unsigned int    OF      :   1;  //  11      overflow flag
    unsigned int    IOPL    :   2;  //  12-13   I/O privilege level
    unsigned int    NT      :   1;  //  14      nested task flag
    unsigned int            :   1;  //  15      reserved always 1
    unsigned int    RF      :   1;  //  16      resume flag
    unsigned int    VM      :   1;  //  17      virtual 8086 mode
    unsigned int    AC      :   1;  //  18      alignment check
    unsigned int    VIF     :   1;  //  19      virtual interrupt flag
    unsigned int    VIP     :   1;  //  20      virtual interrupt pending
    unsigned int    ID      :   1;  //  21      able to use CPUID instruction
    unsigned int            :  10;  //  22-31   reserved
} __attribute__((packed)) eflags_t;

static
eflags_t _get(void)
{
    eflags_t eflags;
 
    asm volatile
        (
            "# get EFLAGS\n\t"
            "pushfl\n\t"
            "popl %0\n\t"
            :   "=r" (eflags)
            :   // no input operands
            :   "cc", "memory"
        );

    return eflags;
}

static
void _set(eflags_t eflags)
{
    asm volatile
        (
            "# set EFLAGS\n\t"
            "pushl %0\n\t"
            "popfl\n\t"
            :   // no output operands 
            :   "r" (eflags)
            :   "cc", "memory"
        );
}

bool eflags_get_intr_flag(void)
{
    eflags_t eflags;

    eflags = _get();
    return eflags.IF;
}

void eflags_set_intr_flag(bool intr_flag)
{
    eflags_t eflags;

    eflags = _get();
    eflags.IF = intr_flag;
    _set(eflags);   
}

